Snake Game na BitDogLab 

Apresentação do Projeto 

O projeto “Snake Game na BitDogLab” consiste no desenvolvimento de um jogo Snake (Cobrinha) utilizando a placa educacional BitDogLab, baseada na Raspberry Pi Pico. O jogo será exibido em uma matriz de LEDs NeoPixel 5x5 e controlado por um joystick analógico, proporcionando uma experiência interativa e educativa em sistemas embarcados. 

Título do Projeto 

Snake Game na BitDogLab 

Objetivos do Projeto 

Os principais objetivos do projeto são: 

Proporcionar uma experiência de jogo interativa e educativa em um sistema embarcado de baixo custo. 

Demonstrar a integração de componentes de hardware (LEDs, joystick, botões) com software embarcado. 

Servir como ferramenta de aprendizado em programação C, manipulação de GPIOs e controle de periféricos. 

Principais Requisitos 

Exibição Gráfica: Matriz de LEDs NeoPixel 5x5 exibindo a cobrinha (verde), frutas (vermelho) e paredes (azul). 

Controle do Jogo: Joystick analógico para movimentação e Botão A (GPIO5) para pausa. 

Lógica do Jogo: Crescimento da cobrinha ao comer frutas, detecção de colisão e geração aleatória de frutas. 

Expansão: Integração futura com display OLED, buzzers ou módulos de comunicação. 

Descrição do Funcionamento 

O jogo exibe a cobrinha e frutas em uma matriz de LEDs controlada por joystick. A cobrinha cresce ao comer frutas e o jogo termina em caso de colisão. Um botão permite pausar e retomar o jogo. O projeto pode ser expandido para incluir pontuação em um display OLED, efeitos sonoros e comunicação com outros dispositivos. 

Justificativa 

O projeto se justifica pelo seu potencial educativo, permitindo que alunos aprendam sobre programação em C, manipulação de hardware e sistemas embarcados de maneira prática e interativa, além de ser um projeto de baixo custo e expansível. 

Originalidade 

Embora existam projetos de jogos Snake para sistemas embarcados, este projeto é original ao utilizar a placa BitDogLab e a Raspberry Pi Pico, integrando uma matriz de LEDs NeoPixel 5x5 e um joystick analógico, com possibilidade de expansão para outros dispositivos, como displays OLED e módulos de comunicação, o que o diferencia de projetos similares. 

 

 

2. Organização do Repositório e Pesquisa de Projetos Correlatos 

2.1 Repositório do Projeto 

O projeto está hospedado em um repositório público no GitHub, que pode ser acessado através do seguinte link: 

Repositório do Projeto: snake_game_Bitdoglab 

A estrutura do repositório é a seguinte: 

snake_game_Bitdoglab/ 
├── build/               # Arquivos compilados gerados durante a construção do projeto. 
├── output/              # Saídas geradas pelo projeto (se aplicável). 
├── .gitignore           # Arquivo para ignorar arquivos desnecessários no Git. 
├── CMakeLists.txt       # Arquivo de configuração do CMake para compilação do projeto. 
├── pico_sdk_import.cmake # Importação do SDK da Raspberry Pi Pico. 
├── README.md            # Documentação principal do projeto, com instruções de uso e descrição. 
├── snake_game.c         # Código-fonte principal do jogo Snake. 
└── ws2818b.pio          # Código PIO para controle dos LEDs NeoPixel (WS2812B). 
  

 

2.2 Pesquisa de Projetos Correlatos 

Durante o desenvolvimento do projeto, foi realizada uma pesquisa sobre projetos semelhantes que utilizam a Raspberry Pi Pico ou microcontroladores para implementar jogos clássicos, como o Snake. A pesquisa teve como objetivo identificar boas práticas, desafios comuns e soluções inovadoras que pudessem ser aplicadas ao projeto. 

2.2.1 Projetos Encontrados 

Snake Game com Raspberry Pi Pico: 

Enquanto uma versão do projeto foi implementada em TypeScript, a minha, desenvolvida em C, utiliza a plataforma BitDogLab para demonstrar sua funcionalidade. A BitDogLab integra recursos avançados, como PIO e DMA, permitindo um controle preciso dos LEDs e uma integração eficiente com dispositivos de entrada, como botões e joystick. Além disso, meu código pode ser acessado e executado diretamente em uma placa BitDogLab, o que o torna mais eficiente, robusto e capaz de oferecer um desempenho superior em sistemas embarcados.  

Referência: GitHub - Projeto Snake . 

Controle de LEDs WS2812B com PIO: 

Enquanto o projeto desenvolvido em Java não pode ser implementado diretamente em uma placa BitDogLab, o meu, desenvolvido em C, utiliza essa plataforma para demonstrar sua funcionalidade. Ele integra recursos avançados, como PIO e DMA, que garantem um controle preciso dos LEDs WS2812B e uma integração eficiente com dispositivos de entrada. Focado na implementação do protocolo WS2812B usando o PIO da Raspberry Pi Pico, meu projeto pode ser acessado e executado diretamente na placa BitDogLab, tornando-o mais eficiente, robusto e ideal para aplicações em sistemas  

Diferencial: Explicação detalhada do funcionamento do PIO e otimização do código para controle de LEDs. 

Referência: GitHub - snake_game. 

2.3 Considerações Finais 

O repositório do projeto foi organizado para ser claro e acessível, seguindo boas práticas de desenvolvimento de software. A pesquisa de projetos correlatos forneceu insights valiosos que foram aplicados ao desenvolvimento do jogo Snake na BitDogLab, garantindo que o projeto esteja alinhado com as melhores práticas da área. 

 

3. Especificação dos Componentes de Hardware 

3.1 Componentes Principais 

Componente 

Função 

Especificações 

Raspberry Pi Pico 

Microcontrolador principal 

Processador ARM Cortex-M0+ de 133 MHz, 264 KB de SRAM, 2 MB de memória flash. 

Matriz de LEDs NeoPixel 5x5 

Exibição do jogo 

25 LEDs endereçáveis individualmente, protocolo WS2812B, controlada via GPIO7. 

Joystick Analógico (KY023) 

Controle da cobrinha 

Eixos X e Y conectados aos GPIO26 e GPIO27, respectivamente. 

Botão A (GPIO5) 

Botão de pausa 

Conectado ao GPIO5, resistor de pull-up interno ativado. 

Display OLED (Opcional) 

Exibição de informações adicionais 

Tamanho: 128x64 pixels, comunicação I2C (GPIO14 - SDA, GPIO15 - SCL). 

 

Especificação/Periféricos da BitDogLab v5.3: 

A placa BitDogLab possui as seguintes dimensões: 99 x 89 x 25 mm (comprimento, largura e altura). 

 

Periféricos usado no projeto: 

 

Matriz de LEDs coloridos (LED-RGB 5x5 5050 WS2812) 

 

Joystick Analógico (Plugin 13x13mm Multi-Dir ROHS) 

 

 

Botões (A e B) - Chave Táctil 12x12x7.5 mm 

 

Botão de reset - 8mm Round Button Brick nogging SPST SMD Tactile Switches ROHS 

Diagrama da BitDogLab: 

 

3.2 Verificação de Requisitos 

Requisitos Atendidos: 

Exibição do jogo na matriz de LEDs. 

Controle preciso da cobrinha com o joystick. 

Lógica do jogo implementada (movimentação, colisões, geração de frutas). 

Requisitos que Podem Ser Expandidos: 

Exibição de pontuação em um display OLED. 

Adição de efeitos sonoros com buzzers. 

 

3.3 Considerações Finais 

Os componentes de hardware da BitDogLab atendem plenamente aos requisitos do projeto, proporcionando uma base sólida para o desenvolvimento do jogo Snake. Apesar de algumas limitações (como o tamanho da matriz de LEDs), o hardware permite expansões futuras, como a integração de um display OLED ou efeitos sonoros. 

4. Especificação do Software 

Critérios do Projeto 

4. Blocos funcionais – Diagrama das camadas do software e suas funções 

 

O diagrama a seguir apresenta as camadas do software e suas funções: 

Camada de Hardware: Inclui o microcontrolador RP2040, LEDs NeoPixel, joystick e botões.Camada de Firmware (PIO e DMA): Contém a programação em Assembly PIO para controle preciso dos LEDs, com a utilização de DMA para transferência eficiente dos dados. 

Camada de Interface: Garante a comunicação com o hardware por meio das APIs PIO. 

Camada de Lógica do Jogo: Implementa a lógica do jogo Snake, abrangendo a movimentação da cobra, a detecção de colisões e a geração de frutas. 

Camada de Aplicação: Engloba a função main() que inicializa e executa o jogo. 

4.1.1 Descrição das funcionalidades 

Cada camada do software desempenha funções específicas, como o controle dos LEDs, a leitura das entradas e o gerenciamento da lógica do jogo. 

4.1.2 Definição das variáveis 

Contém as variáveis referentes à posição da cobra, ao estado do jogo, às entradas do joystick e à cor dos LEDs. 

4.1.3 Fluxograma 

 

O fluxograma completo do software mostra a inicialização, leitura de entradas, atualização do jogo e controle dos LEDs. 

4.1.4 Inicialização – Descrição do processo de inicialização do software 

O processo de inicialização configura os periféricos e o ambiente de execução: 

npInit(uint pin): Configura o PIO para o controle dos LEDs. 

joystick_init(): Inicializa os pinos ADC para o joystick. 

button_init(): Configura o botão A como entrada com pull-up. 

game_init(): Define o estado inicial do jogo. 

4.1.5 Configurações dos registros – Descrição das funções de configuração dos registros 

Os registros do PIO são configurados para: 

Definir a frequência de comunicação com os LEDs. 

Configurar o pino de saída dos LEDs. 

Ajustar o divisor de clock e o FIFO para transmissão de dados. 

4.1.6 Estrutura e formato dos dados – Dados específicos usados no software 

Estrutura para a cobra (posição e tamanho). 

Variável para a posição da fruta. 

Dados do joystick e botões armazenados em variáveis globais. 

4.1.7 Estrutura Geral do Código 

Blocos funcionais organizados com #pragma region: 

LEDs NeoPixel, lógica do jogo, joystick, botões e main. 

4.1.8 Funções Principais 

npInit(), game_init(), joystick_init(), button_init(). 

4.1.9 Considerações Finais 

O software é modular e extensível. 

4.1.10 Organização da memória – Endereços de memória usados 

A memória do RP2040 é utilizada para armazenar o estado do jogo, posições dos LEDs e entradas dos controles. 

4.1.11 Protocolo de comunicação – Descrição do protocolo, se existir 

Protocolo de comunicação com os LEDs NeoPixel baseado em PWM programável via PIO. 

4.1.12 Formato do pacote de dados – Formação dos pacotes, se existir 

Pacotes de 24 bits para controle de cores RGB dos LEDs, enviados sequencialmente. 

 

5. Implementação do Projeto 

5.1 Configuração do Ambiente de Desenvolvimento 

Ferramentas Necessárias: 

Raspberry Pi Pico SDK. 

CMake. 

GCC Arm Toolchain. 

Visual Studio Code (opcional). 

 

5.2 Compilação do Projeto 

Criar o diretório de build:mkdir build 
cd build 
  

Configurar o CMake:cmake .. 
  

Compilar o projeto:make 
  

 

5.3 Gravação do Firmware na Raspberry Pi Pico 

Conectar a Raspberry Pi Pico ao computador via USB. 

Copiar o arquivo .uf2 gerado para a unidade USB da Pico. 

 

5.4 Execução do Jogo Snake 

Controles: 

Joystick: Movimentação da cobrinha. 

Botão A: Pausa/retomada do jogo. 

 

6. Testes de Validação 

6.1 Testes de Hardware 

Matriz de LEDs: Todos os LEDs funcionaram corretamente. 

Joystick: Valores consistentes para cada direção. 

Botão A: Alternância correta do estado de pausa. 

6.2 Testes de Software 

Movimentação da Cobrinha: Funcionamento correto em todas as direções. 

Colisões: Detecção de colisões com paredes e corpo da cobrinha. 

Geração de Frutas: Posições aleatórias sem sobreposição com a cobrinha. 

 

6.3 Considerações Finais 

Todos os testes de validação foram realizados com sucesso, confirmando que o projeto atende aos requisitos funcionais e técnicos. O jogo Snake funciona corretamente na BitDogLab, com controle preciso, exibição adequada e detecção de colisões. 

 

7. Referências 

7.1 Documentação da Raspberry Pi Pico 
A documentação oficial da Raspberry Pi Pico fornece informações detalhadas sobre o microcontrolador, suas especificações técnicas e como utilizar o SDK para desenvolvimento. 
Disponível em: Raspberry Pi Pico Documentation. 

7.2 Repositório do Projeto no GitHub 
O repositório público do projeto contém todo o código-fonte, documentação e recursos relacionados ao desenvolvimento do jogo Snake na BitDogLab. 
Acesso em: snake_game_Bitdoglab. 

7.3 BitDogLab no GitHub 
O repositório oficial da BitDogLab oferece exemplos de uso, esquemas de hardware e informações sobre a placa educacional baseada na Raspberry Pi Pico. 
Disponível em: BitDogLab GitHub. 

8. Vídeo mostrando o uso na BitDogLab 

Vídeo demonstrando as funcionalidades do jogo Snake Game na placa, com duração máxima de 3 minutos. 

Disponível em: 